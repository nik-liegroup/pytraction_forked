from pytraction.core import (
    TractionForceConfig,
    _find_uv_outside_single_polygon,
    _custom_noise,
    _get_noise,
    _write_frame_results,
    _write_metadata_results,
    process_stack,
)

import numpy as np
# from skimage import io
import tifffile
import tempfile
import os
from scipy.ndimage.filters import gaussian_filter
import pickle

def test__custom_noise():
    np.random.seed(999)


    # dummy config
    class Config():
        def __init__(self) -> None:
            config = None
    
    # fix config / using dummy window size of 32
    config = Config()
    config.config = {'piv': {'min_window_size': 32, 'overlap_ratio': 0.5, 'coarse_factor': 0, 'dt': 1, 'validation_method': 'mean_velocity', 'trust_1st_iter': 0, 'validation_iter': 3, 'tolerance': 1.5, 'nb_iter_max': 1, 'sig2noise_method': 'peak2peak'}, 'tfm': {'E': 'None', 's': 'None', 'meshsize': 'None', 'pix_per_mu': 'None'}, 'settings': {'bead_channel': 0, 'cell_channel': 1, 'segment': False, 'device': 'cpu'}}

    # generate 300 particles
    x = np.random.randint(10, 246, 300)
    y = np.random.randint(10, 246, 300)
    
    # get x and y sizes
    xsize = int(np.max(x))
    ysize = int(np.max(y))
    
    # create image with no particles
    img = np.zeros((xsize, ysize))

    # for each particle at [i,j] make a square
    for i, j in zip(x,y):
        # get random bead radius with center i,j
        particle_radius = int(np.random.randint(3, 6, 1))
        cx, cy = int(i)-1, int(j)-1
        # make particle at i,j with radius r
        img[cx-particle_radius: cx+particle_radius, cy-particle_radius: cy+particle_radius] = 255

    # apply gaussian blur to filter
    img = gaussian_filter(img, sigma=3)
    # generate random noise
    noise = np.random.randint(0, 125, size=xsize*ysize).reshape(((xsize, ysize)))
    # combine noise + img
    img = img + noise
    # make sure the image is between [0-255] and uint8
    img = np.array(img*255/np.max(img), dtype='uint8')

    stacks = []
    for _ in range(4):
        noise = np.random.randint(0, 125, size=xsize*ysize).reshape(((xsize, ysize)))
        # combine noise + img
        img_stack = img + noise
        stacks.append(img_stack)
    
    # save the autogenerated tifffile
    # the stack must have dims (t, w, h)
    tiffstack = np.stack(stacks)
    tmppath = tempfile.gettempdir() + 'stack.tiff'
    
    # save the tiff to file 
    tifffile.imwrite(tmppath, data=tiffstack, shape=tiffstack.shape)

    # test the function
    beta = _custom_noise(tmppath, config)


    # get the temp dir of the cache
    tmpdir = tempfile.gettempdir()
    destination = f'{tmpdir}/tmp_noise.pickle'

    # read in the cached noise
    with open(destination, 'rb') as f:
        cache = pickle.load(f)


    assert os.path.exists(tmppath)
    assert os.path.exists(destination)
    assert beta == 3.9170344130375994
    assert cache[tmppath] == beta



def test__find_uv_outside_single_polygon():
    pass
    # _find_uv_outside_single_polygon
